using Microsoft.EntityFrameworkCore;
using progQuiz.API.Models;

namespace progQuiz.API.Data;

public class ApplicationDbContext : DbContext
{
    public DbSet<User> Users { get; set; }
    public DbSet<LevelResult> LevelResults { get; set; }
    
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
        
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
        SeedData(modelBuilder);
    }
    private void SeedData(ModelBuilder modelBuilder)
    {

        var levels = new List<Level>
        {
            new Level
            {
                LevelId = 1,
                Name = "Введение в C#",
                Length = 9,
                Theory = "<section>\n    <h1>Программирование</h1>\n    <p>Программирование - это процесс создания набора инструкций, которые компьютер может выполнить для решения определенной задачи. Язык программирования - это формальный набор синтаксических и семантических правил, которые определяют, как написать программный код для достижения желаемого результата.</p>\n</section>\n\n<section>\n    <h2>История языка C#</h2>\n    <p>C# был разработан в 2000 году командой под руководством Андерса Хейлсберга в Microsoft. Он создавался как часть .NET Framework для разработки приложений под платформу Windows. Название \"C#\" происходит от символа, который используется в музыкальной нотации для обозначения диеза (C# - \"до-диез\").</p>\n    <p>Впервые C# был представлен публично в январе 2000 года и стал доступным в 2002 году. С тех пор C# стал одним из основных языков программирования в экосистеме Microsoft.</p>\n</section>\n\n<section>\n    <h2>Применение C#</h2>\n    <p>C# широко используется для разработки различных видов программного обеспечения, включая:</p>\n    <ul>\n        <li>Веб-приложения: С использованием ASP.NET и ASP.NET Core можно создавать мощные веб-приложения и веб-сервисы.</li>\n        <li>Настольные приложения: С помощью технологии Windows Forms или WPF можно разрабатывать настольные приложения для платформы Windows.</li>\n        <li>Игры: С использованием фреймворка Unity и языка C# создаются множество современных видеоигр.</li>\n        <li>Мобильные приложения: С помощью Xamarin можно разрабатывать кросс-платформенные мобильные приложения для Android и iOS на языке C#.</li>\n        <li>Системное программирование: C# используется для разработки различных компонентов операционных систем Windows и встраиваемых систем.</li>\n    </ul>\n    <p>Поскольку C# интегрируется с платформой .NET, он обладает множеством возможностей и библиотек, что делает его мощным инструментом для разработки программного обеспечения различных типов и масштабов.</p>\n</section>\n\n<section>\n    <h2>Типы данных</h2>\n    <p>Тип данных определяет набор значений, которые может содержать переменная, а также операции, которые можно выполнять с этими значениями. Вот некоторые основные типы данных в C#:</p>\n    <ul>\n        <li>int (целые числа): Представляет целые числа со знаком, например, -3, 0, 42.</li>\n        <li>float (вещественные числа одинарной точности): Представляет вещественные числа одинарной точности, например, 3.14, -0.001, 123.456.</li>\n        <li>double (вещественные числа двойной точности): Представляет вещественные числа двойной точности, например, 3.14, -0.001, 123.456.</li>\n        <li>char (символы): Представляет одиночный символ в кодировке Unicode, например, 'a', 'B', '?'.</li>\n        <li>bool (логические значения): Представляет значение истина (true) или ложь (false).</li>\n        <li>string (строки): Представляет набор символов, например, \"Привет, мир!\", \"12345\".</li>\n    </ul>\n</section>\n\n<section>\n    <h2>Операции</h2>\n    <p>Операции - это символы или ключевые слова, используемые для выполнения операций над данными. В C# есть различные типы операций для разных типов данных:</p>\n    <h3>Арифметические операции:</h3>\n    <ul>\n        <li>+ (сложение): Складывает два операнда.</li>\n        <li>- (вычитание): Вычитает второй операнд из первого.</li>\n        <li>* (умножение): Перемножает два операнда.</li>\n        <li>/ (деление): Делит первый операнд на второй.</li>\n        <li>% (остаток от деления): Возвращает остаток от деления первого операнда на второй.</li>\n    </ul>\n    <h2>Операции сравнения:</h2>\n    <ul>\n        <li>== (равно): Возвращает true, если операнды равны.</li>\n        <li>!= (не равно): Возвращает true, если операнды не равны.</li>\n        <li>&lt; (меньше): Возвращает true, если первый операнд меньше второго.</li>\n        <li>&gt; (больше): Возвращает true, если первый операнд больше второго.</li>\n        <li>&lt;= (меньше или равно): Возвращает true, если первый операнд меньше или равен второму.</li>\n        <li>&gt;= (больше или равно): Возвращает true, если первый операнд больше или равен второму.</li>\n    </ul>\n    <h2>Логические операции:</h2>\n    <ul>\n        <li>&& (логическое И): Возвращает true, если оба операнда равны true.</li>\n        <li>|| (логическое ИЛИ): Возвращает true, если хотя бы один из операндов равен true.</li>\n        <li>! (логическое НЕ): Инвертирует значение операнда.</li>\n    </ul>\n</section>\n  ",
            },
            new Level
            {
                LevelId = 2,
                Name = "Управляющие конструкции",
                Length = 8,
                Theory = "<section>\n    <h2>Условные операторы: if, else if, else</h2>\n    <p>Условные операторы позволяют выполнять определенный блок кода, только если заданное условие истинно. В C# основным условным оператором является if. Синтаксис if выглядит следующим образом:</p>\n    <pre class=\"kod\">\n    <code>\n        if (условие)\n        {\n            // Код, который выполняется, если условие \n            истинно\n        }\n    </code>\n    </pre>\n    <p>Если условие истинно, то код внутри блока {} выполняется. В противном случае, если условие ложно, код внутри блока {} пропускается.</p>\n    <p>Можно также использовать else if, чтобы проверить дополнительные условия, если первое условие не истинно. А также else, который выполняется, если все предыдущие условия ложны. Пример:</p>\n    <pre class=\"kod\">\n    <code>\n        int x = 10;\n        if (x > 10)\n        {\n            Console.WriteLine(\"x больше 10\");\n        }\n        else if (x < 10)\n        {\n            Console.WriteLine(\"x меньше 10\");\n        }\n        else\n        {\n            Console.WriteLine(\"x равно 10\");\n        }\n    </code>\n    </pre>\n</section>\n\n<section>\n    <h2>Циклы: for, while, do-while</h2>\n    <p>Циклы используются для повторения определенного блока кода несколько раз.</p>\n    <p>for: Цикл for используется, когда известно количество итераций, которые должен выполнить цикл. Синтаксис:</p>\n    <pre class=\"kod\">\n    <code>\n        for (начальное_условие; условие_продолжения; \n            выражение_итерации)\n        {\n            // Код, который повторяется\n        }\n    </code>\n    </pre>\n    <p>while: Цикл while выполняется, пока условие истинно. Синтаксис:</p>\n    <pre class=\"kod\">\n        \n    while (условие)\n    {\n        // Код, который выполняется, пока \n        условие истинно\n    }\n        \n    </pre>\n    <p>do-while: Этот цикл похож на while, но он гарантирует, что блок кода выполнится хотя бы один раз перед проверкой условия. Синтаксис:</p>\n    <pre class=\"kod\">\n       \n    do\n    {\n        // Код, который выполняется, пока \n        условие истинно\n    }\n    while (условие);\n        \n    </pre>\n</section>\n\n<section>\n    <h2>Операторы ветвления: switch</h2>\n    <p>Оператор switch используется для выбора одного из множества блоков кода для выполнения, на основе значения выражения. Синтаксис:</p>\n    <pre className={classes.kod}>\n        <code>\n    switch (выражение)\n    {\n        case значение1:\n            // Код, выполняемый при совпадении с первым \n            значением\n            break;\n        case значение2:\n            // Код, выполняемый при совпадении со вторым \n            значением\n            break;\n        default:\n            // Код, выполняемый, если ни одно значение \n            не совпало\n            break;\n    }\n        </code>\n    </pre>\n    <p>Ключевое слово break используется для выхода из оператора switch. Без break выполнение кода будет продолжаться независимо от совпадений.</p>\n</section>`",
            },
            new Level
            {
                LevelId = 3,
                Name = "Массивы и коллекции",
                Length = 9,
                Theory = "<section>\n    <h2>Массивы:</h2>\n    <p>Массивы представляют собой упорядоченные коллекции элементов одного типа данных. Они предоставляют удобный способ хранения множества значений одного типа.</p>\n    \n    <h3>Объявление и инициализация массивов:</h3>\n    <pre><code>\n    // Одномерный массив целых чисел с 5 элементами\n    int[] numbers = new int[5];\n    // Инициализация элементов массива при объявлении\n    int[] numbers = {1, 2, 3, 4, 5};\n    \n    // Двумерный массив целых чисел 3x3\n    int[,] matrix = new int[3, 3];\n    // Инициализация двумерного массива\n    int[,] matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };\n    </code></pre>\n    \n    <h3>Работа с элементами массива:</h3>\n    <pre><code>\n    int[] numbers = {1, 2, 3, 4, 5};\n    // Доступ к элементам массива по индексу\n    int firstNumber = numbers[0]; // 1\n    int lastNumber = numbers[numbers.Length - 1]; \n    // 5 (длина массива - 1)\n    \n    // Изменение элемента массива\n    numbers[2] = 10; // Замена третьего элемента на 10\n    </code></pre>\n    \n    <h3>Методы массивов:</h3>\n    <p>В C# массивы предоставляют ряд встроенных методов для удобного выполнения различных операций с массивами.</p>\n    <ol>\n      <li>\n        <h4>Length:</h4>\n        <pre><code>\n    int[] numbers = {1, 2, 3, 4, 5};\n    int length = numbers.Length; // length равен 5\n        </code></pre>\n      </li>\n      \n      <li>\n        <h4>CopyTo:</h4>\n        <pre><code>\n    int[] source = {1, 2, 3, 4, 5};\n    int[] target = new int[5];\n    source.CopyTo(target, 0); // Копирование элементов из source в target, \n                                начиная с индекса 0\n        </code></pre>\n      </li>\n      \n      <li>\n        <h4>IndexOf:</h4>\n        <pre><code>\n    int[] numbers = {10, 20, 30, 40, 50};\n    int index = Array.IndexOf(numbers, 30); // index равен 2\n        </code></pre>\n      </li>\n      \n      <li>\n        <h4>Reverse:</h4>\n        <pre><code>\n    int[] numbers = {1, 2, 3, 4, 5};\n    Array.Reverse(numbers); // Теперь numbers содержит \n                                {5, 4, 3, 2, 1}\n        </code></pre>\n      </li>\n      \n      <li>\n        <h4>Sort:</h4>\n        <pre><code>\n    int[] numbers = {5, 2, 4, 1, 3};\n    Array.Sort(numbers); // Теперь numbers содержит\n                             {1, 2, 3, 4, 5}\n        </code></pre>\n      </li>\n    </ol>\n  </section>\n  \n  <section>\n    <h2>Коллекции:</h2>\n    <p>Коллекции представляют собой классы, которые предоставляют гибкое хранение и управление данными. Некоторые из наиболее популярных коллекций в C# включают List, Dictionary и HashSet.</p>\n    \n    <h3>List:</h3>\n    <pre><code>\n    // Создание и инициализация списка целых чисел\n    List<int> numbers = new List<int>();\n    numbers.Add(1);\n    numbers.Add(2);\n    numbers.Add(3);\n    \n    // Доступ к элементам списка\n    int firstNumber = numbers[0]; // 1\n    \n    // Удаление элемента из списка\n    numbers.Remove(2); // Удаление элемента со значением 2\n    </code></pre>\n    \n    <h3>Dictionary:</h3>\n    <pre><code>\n    // Создание и инициализация словаря\n    Dictionary<string, int> ages = new Dictionary<string, int>();\n    ages.Add(\"Alice\", 30);\n    ages.Add(\"Bob\", 25);\n    \n    // Доступ к элементам словаря по ключу\n    int aliceAge = ages[\"Alice\"]; // 30\n    \n    // Удаление элемента из словаря\n    ages.Remove(\"Bob\"); // Удаление элемента с ключом \"Bob\"\n    </code></pre>\n    \n    <h3>HashSet:</h3>\n    <pre><code>\n    // Создание и инициализация множества\n    HashSet<int> set = new HashSet<int>();\n    set.Add(1);\n    set.Add(2);\n    set.Add(3);\n    set.Add(1); // Дубликаты будут проигнорированы\n    \n    // Проверка наличия элемента в множестве\n    bool containsTwo = set.Contains(2); // true\n    \n    // Удаление элемента из множества\n    set.Remove(3); // Удаление элемента со значением 3\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Многомерные массивы и коллекции:</h2>\n    <p>Многомерные массивы и коллекции представляют собой массивы и коллекции с более чем двумя измерениями. Они используются для хранения данных в виде таблиц или матриц.</p>\n    \n    <pre><code>\n    // Двумерный массив целых чисел 3x3\n    int[,] matrix = new int[3, 3];\n    \n    // Инициализация двумерного массива\n    int[,] matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };\n    </code></pre>\n  </section>\n  ",
            },
            new Level
            {
                LevelId = 4,
                Name = "Методы и функции",
                Length = 8,
                Theory = "<section>\n    <h2>Объявление и вызов методов: Параметры, возвращаемые значения</h2>\n    <p>Методы представляют собой блоки кода, которые выполняют определенные задачи. Они могут принимать входные данные (параметры), выполнять операции над ними и возвращать результаты.</p>\n    \n    <h3>Объявление метода:</h3>\n    <pre><code>\n      // Метод без параметров и возвращаемого значения\n      void PrintHello()\n      {\n          Console.WriteLine(\"Hello!\");\n      }\n  \n      // Метод с параметрами и возвращаемым значением\n      int Add(int a, int b)\n      {\n          return a + b;\n      }\n    </code></pre>\n    \n    <p>В первом примере метод PrintHello не принимает параметры и не возвращает значения. Он просто выводит на консоль приветствие \"Hello!\". Во втором примере метод Add принимает два параметра типа int и возвращает их сумму.</p>\n    \n    <h3>Вызов метода:</h3>\n    <pre><code>\n      PrintHello(); // Вызов метода без параметров и \n      возвращаемого значения\n  \n      int sum = Add(3, 5); // Вызов метода с параметрами и \n      возвращаемым значением\n    </code></pre>\n    \n    <p>Метод PrintHello() вызывается без аргументов, поскольку он не принимает параметры. Метод Add(3, 5) вызывается с двумя аргументами (числами 3 и 5), которые передаются методу для выполнения операции сложения.</p>\n  </section>\n  \n  <section>\n    <h2>Рекурсия: Основы и примеры</h2>\n    <p>Рекурсия - это процесс, при котором метод вызывает сам себя. Она часто используется для решения задач, которые могут быть разбиты на более мелкие подзадачи. Рекурсивные методы включают базовый случай, который определяет конечное условие цикла.</p>\n    \n    <h3>Пример рекурсивного метода: Факториал</h3>\n    <pre><code>\n      int Factorial(int n)\n      {\n          if (n == 0)\n              return 1; // Базовый случай: факториал 0 равен 1\n          else\n              return n * Factorial(n - 1); // Рекурсивный вызов \n                                                метода\n      }\n    </code></pre>\n    \n    <p>В этом примере метод Factorial рекурсивно вызывает сам себя, пока n не достигнет 0. Когда n равно 0, возвращается 1 (базовый случай), в противном случае возвращается произведение n на факториал (n - 1).</p>\n  </section>\n  \n  <section>\n    <h2>Область видимости переменных: Локальные и глобальные переменные, модификаторы доступа</h2>\n    \n    <h3>Локальные переменные:</h3>\n    <p>Локальные переменные объявляются внутри метода и доступны только внутри этого метода.</p>\n    <pre><code>\n      void PrintNumber()\n      {\n          int number = 10; // Локальная переменная\n          Console.WriteLine(number);\n      }\n    </code></pre>\n    \n    <p>Переменная number является локальной для метода PrintNumber и не может быть использована за его пределами.</p>\n    \n    <h3>Глобальные переменные:</h3>\n    <p>Глобальные переменные объявляются вне методов и доступны для всех методов в классе. Они должны использоваться с осторожностью из-за потенциальных проблем с читаемостью и поддержкой кода.</p>\n    <pre><code>\n      class Program\n      {\n          int globalVariable = 20; // Глобальная переменная\n  \n          void PrintGlobalVariable()\n          {\n              Console.WriteLine(globalVariable);\n          }\n      }\n    </code></pre>\n    \n    <p>Переменная globalVariable является глобальной для класса Program и может быть использована внутри всех его методов.</p>\n    \n    <h3>Модификаторы доступа:</h3>\n    <p>Модификаторы доступа управляют доступом к переменным и методам из других частей программы.</p>\n    <ul>\n      <li><strong>public:</strong> Публичные переменные и методы доступны из любой части программы.</li>\n      <li><strong>private:</strong> Приватные переменные и методы доступны только внутри того же класса.</li>\n      <li><strong>protected:</strong> Защищенные переменные и методы доступны только внутри того же класса и его наследников.</li>\n      <li><strong>internal:</strong> Переменные и методы с модификатором internal доступны только внутри сборки.</li>\n    </ul>\n    <pre><code>\n      public class MyClass\n      {\n          private int privateVariable; // Приватная переменная\n          public int publicVariable; // Публичная переменная\n      }\n    </code></pre>\n    \n    <p>Модификаторы доступа позволяют контролировать доступ к переменным и методам, что способствует безопасности и обеспечивает чистоту кода.</p>\n  </section>",
            },
            new Level
            {
                LevelId = 5,
                Name = "Объектно-ориентированное программирование",
                Length = 14,
                Theory = "<section>\n    <h2>Классы и объекты</h2>\n    <p>Класс - это шаблон или формальное описание объекта, определяющее его свойства (поля) и действия (методы). Объект - это конкретный экземпляр класса, который имеет свои собственные уникальные значения свойств.</p>\n    <pre><code>\n      class Car\n      {\n          public string Model;\n          public string Color;\n  \n          public void Start()\n          {\n              Console.WriteLine(\"The car is started.\");\n          }\n      }\n  \n      Car myCar = new Car();\n      myCar.Model = \"Toyota\";\n      myCar.Color = \"Red\";\n      myCar.Start();\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Абстракция</h2>\n    <p>Абстракция - это процесс выделения общих характеристик объекта, игнорируя детали реализации. В ООП абстракция позволяет скрывать сложные детали и предоставлять простой интерфейс для взаимодействия с объектами.</p>\n    <pre><code>\n      abstract class Shape\n      {\n          public abstract double Area();\n      }\n  \n      class Circle : Shape\n      {\n          public double Radius;\n  \n          public override double Area()\n          {\n              return Math.PI * Radius * Radius;\n          }\n      }\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Инкапсуляция</h2>\n    <p>Инкапсуляция - это концепция, которая скрывает детали реализации объекта и предоставляет только интерфейс для взаимодействия с ним. В ООП инкапсуляция достигается с помощью доступа к полям и методам объекта.</p>\n    <pre><code>\n      class BankAccount\n      {\n          private decimal balance;\n  \n          public decimal Balance\n          {\n              get { return balance; }\n              set { balance = value; }\n          }\n  \n          public void Deposit(decimal amount)\n          {\n              balance += amount;\n          }\n  \n          public void Withdraw(decimal amount)\n          {\n              if (balance >= amount)\n                  balance -= amount;\n              else\n                  Console.WriteLine(\"Insufficient funds.\");\n          }\n      }\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Наследование и полиморфизм</h2>\n    <h3>Наследование</h3>\n    <p>Наследование - это механизм ООП, который позволяет создавать новые классы на основе существующих. При наследовании новый класс (подкласс) получает свойства и методы своего родительского класса (суперкласса).</p>\n    <pre><code>\n      class Animal\n      {\n          public void Eat()\n          {\n              Console.WriteLine(\"Animal is eating.\");\n          }\n      }\n  \n      class Dog : Animal\n      {\n          public void Bark()\n          {\n              Console.WriteLine(\"Dog is barking.\");\n          }\n      }\n    </code></pre>\n  \n    <h3>Полиморфизм</h3>\n    <p>Полиморфизм - это способность объекта использовать методы разных классов в зависимости от контекста. Полиморфизм позволяет использовать одно и то же имя метода для различных классов.</p>\n    <pre><code>\n      class Animal\n      {\n          public virtual void Sound()\n          {\n              Console.WriteLine(\"Animal makes a sound.\");\n          }\n      }\n  \n      class Dog : Animal\n      {\n          public override void Sound()\n          {\n              Console.WriteLine(\"Dog barks.\");\n          }\n      }\n  \n      class Cat : Animal\n      {\n          public override void Sound()\n          {\n              Console.WriteLine(\"Cat meows.\");\n          }\n      }\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Интерфейсы и абстрактные классы</h2>\n    <h3>Интерфейсы</h3>\n    <p>Интерфейс - это контракт, который определяет набор методов и свойств, которые класс должен реализовать. Интерфейсы позволяют реализовывать множественное наследование и обеспечивают гибкость при проектировании.</p>\n    <pre><code>\n      interface IShape\n      {\n          double Area();\n      }\n  \n      class Circle : IShape\n      {\n          public double Radius;\n  \n          public double Area()\n          {\n              return Math.PI * Radius * Radius;\n          }\n      }\n    </code></pre>\n  \n    <h3>Абстрактные классы</h3>\n    <p>Абстрактный класс - это класс, который не может быть инстанциирован, а может содержать как реализованные, так и нереализованные (абстрактные) методы. Он служит базовым классом для других классов.</p>\n    <pre><code>\n      abstract class Shape\n      {\n          public abstract double Area();\n      }\n  \n      class Circle : Shape\n      {\n          public double Radius;\n  \n          public override double Area()\n          {\n              return Math.PI * Radius * Radius;\n          }\n      }\n    </code></pre>\n  </section>",
            },
            new Level
            {
                LevelId = 6,
                Name = "Обработка ошибок и исключения",
                Length = 11,
                Theory = "<section>\n    <h2>Обработка исключений: try-catch блок</h2>\n    <p>В блоке try размещается код, который может привести к исключению. Если исключение происходит, выполнение кода в блоке try прерывается, и управление передается в блок catch, где можно обработать исключение.</p>\n    <pre><code>\n      try\n      {\n          // Блок кода, где может произойти исключение\n          int result = 10 / 0; // Попытка деления на ноль\n      }\n      catch (Exception ex)\n      {\n          // Блок кода, который выполняется при возникновении \n                                                исключения\n          Console.WriteLine(\"An error occurred: \" \n          + ex.Message);\n      }\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Обработка исключений: finally блок</h2>\n    <p>Блок finally выполняется в любом случае, независимо от того, произошло ли исключение или нет. Он используется для освобождения ресурсов или выполнения завершающих действий.</p>\n    <pre><code>\n      try\n      {\n          // Блок кода, где может произойти исключение\n      }\n      catch (Exception ex)\n      {\n          // Блок кода, который выполняется при возникновении \n                                                исключения\n      }\n      finally\n      {\n          // Блок кода, который выполняется в любом случае\n          Console.WriteLine(\"Finally block is executed.\");\n      }\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Пользовательские исключения</h2>\n    <p>Пользовательские исключения - это специальные классы, которые наследуются от базового класса Exception и используются для обработки специфических ситуаций в приложении.</p>\n    <pre><code>\n      class MyCustomException : Exception\n      {\n          public MyCustomException(string message) : base\n                                                    (message)\n          {\n          }\n      }\n  \n      class Program\n      {\n          static void Main(string[] args)\n          {\n              try\n              {\n                  throw new MyCustomException(\"This is a custom \n                  exception.\");\n              }\n              catch (MyCustomException ex)\n              {\n                  Console.WriteLine(\"Custom exception caught: \" \n                  + ex.Message);\n              }\n          }\n      }\n    </code></pre>\n  </section>\n  \n  <section>\n    <h2>Лучшие практики программирования</h2>\n    <h3>Отладка</h3>\n    <p>Используйте отладчик для поиска и устранения ошибок в коде. Установите точки останова (breakpoints), следите за значениями переменных и используйте инструменты отладки для анализа выполнения программы.</p>\n  \n    <h3>Комментирование кода</h3>\n    <p>Пишите понятные и информативные комментарии к коду. Комментарии должны объяснять, что делает код, особенности его реализации и любые другие важные детали.</p>\n  \n    <h3>Структурирование проекта</h3>\n    <p>Соблюдайте правила структурирования проекта. Разделяйте код на логические модули и используйте пространства имен для организации классов. Это поможет улучшить читаемость, поддерживаемость и масштабируемость вашего кода.</p>\n  </section>",
            }
        };

        modelBuilder.Entity<Level>().HasData(levels);
        
    }
}